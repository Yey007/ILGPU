<#@ template hostspecific="true" language="C#" #>
<#@ output extension=".cs"#>
<#@ include file="BuilderCommon.ttinclude"#>
<#
    Dictionary<string, SPIRVType> LoadOperandTypeInfoMap()
    {
        var infoMap = new Dictionary<string, SPIRVType>();

        foreach (var instruction in grammar.Instructions.Instructions)
        {
            if (instruction.Operands?.Operands == null)
            {
                continue;
            }

            foreach (var operand in instruction.Operands.Operands)
            {
                var type = grammar.Types.Types.Find(x => x.Name == operand.Type);
                infoMap[operand.Type] = type;
            }
        }

        return infoMap;
    }
#>
<#
    var typeInfo = LoadOperandTypeInfoMap();

    void CreateAppendBasic(string category, string typeName, string paramName)
    {
        if (typeName == "IdResult")
        {
#>_builder.Append(<#= paramName#>.ToRepr() + " = ");
<#
        }
        else
        {
#>_builder.Append(<#= paramName#>.ToRepr() + " ");
<#
        }
    }

    void CreateAppend(SPIRVType spirvType, string paramName)
    {
        switch (spirvType.Category)
        {
            case "Id":
            case "Literal":
            case "BitEnum":
            case "ValueEnum":
                CreateAppendBasic(spirvType.Category, spirvType.Name, paramName);
                break;
            case "Composite":
                for (int i = 0; i < spirvType.Bases.Bases.Count; i++)
                {
                    var type = typeInfo[spirvType.Bases.Bases[i]];
                    CreateAppendBasic(
                        type.Category,
                        type.Name,
                        $"{paramName}.base{i}"
                    );
                }
                break;
        }
    }

    void CreateBody(string opName, List<(SPIRVOperand operand, string name)> paramInfos)
    {
#> {
<#
        PushIndent(standardIndent);

        // IdResult must always come first in string form (but not in binary form)
        int index = paramInfos.FindIndex(pair => pair.operand.Type == "IdResult");
        if (index != -1)
        {
            var param = paramInfos[index];
            var type = typeInfo[param.operand.Type];
            CreateAppend(type, param.name);
            paramInfos.RemoveAt(index);
        }
#>_builder.Append("<#= opName#> ");
<#
        for (int i = 0; i < paramInfos.Count; i++)
        {
            var (operand, name) = paramInfos[i];
            var type = typeInfo[operand.Type];
            if (string.IsNullOrWhiteSpace(operand.Quantifier))
            {
                CreateAppend(type, name);
            }
            else if (operand.Quantifier == "?")
            {
#>if(<#= name#> is <#= operand.Type#> <#= name#>NotNull) {
<#              PushIndent(standardIndent);
                CreateAppend(type, name + "NotNull");
                PopIndent();
#>
}
<#
            }
            else if (operand.Quantifier == "*")
            {
#>for (int i = 0; i < <#= name#>.Length; i++) {
<#              PushIndent(standardIndent);
                CreateAppend(type, name + "[i]");
                PopIndent();
#>
}
<#
            }
        }
#>_builder.AppendLine();
<#
        PopIndent();
#>
}

<#
    }
#>
using System;
using System.Text;
using ILGPU.Backends.SPIRV.Types;

#nullable enable

namespace ILGPU.Backends.SPIRV
{

<#
    PushIndent(standardIndent);
#>
internal class StringSPIRVBuilder : ISPIRVBuilder {

    private StringBuilder _builder = new StringBuilder();

    public byte[] ToByteArray() => Encoding.UTF8.GetBytes(_builder.ToString());

    public void AddMetadata(
        SPIRVWord magic,
        SPIRVWord version,
        SPIRVWord genMagic,
        SPIRVWord bound,
        SPIRVWord schema)
    {
        _builder.AppendLine($"; Magic: {magic.Data:X}");
        _builder.AppendLine($"; Version: {version.Data:X}");
        _builder.AppendLine($"; Generator Magic: {genMagic.Data:X}");
        _builder.AppendLine($"; Bound: {bound}");
        _builder.AppendLine($"; Schema: {schema}");
    }

    public void Merge(ISPIRVBuilder other) {
        if(other == null) {
            throw new ArgumentNullException(nameof(other));
        }

        var otherString = other as StringSPIRVBuilder;
        if(otherString == null) {
            throw new InvalidCodeGenerationException(
                "Attempted to merge binary builder with string representation builder"
            );
        }

        _builder.Append(otherString._builder);
    }

<#
    PushIndent(standardIndent);
    foreach (var instruction in grammar.Instructions.Instructions)
    {
        var paramInfos = GenerateParamInfos(instruction);
        CreateHeader(instruction.OpName, paramInfos);
        CreateBody(instruction.OpName, paramInfos);
    }
    PopIndent();
#>
}
<#
    PopIndent();
#>
}