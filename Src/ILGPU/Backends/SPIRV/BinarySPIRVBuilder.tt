<#@ template hostspecific="true" language="C#" #>
<#@ output extension=".cs"#>
<#@ include file="BuilderCommon.ttinclude"#>
<#@ assembly name="System.Core" #>
<#
    void CreateBody(int opCode, List<(SPIRVOperand operand, string name)> paramInfos)
    {
#> {
<#
        PushIndent(standardIndent);
        if (paramInfos.Count != 0)
        {
#>var tempList = new List<uint>();
<#
        }

        foreach (var (operand, name) in paramInfos)
        {
            if (operand.Quantifier == "?")
            {
#>if(<#= name#> != null)
    tempList.AddRange(<#= name #>.ToUintList());
<#
            }
            else if (operand.Quantifier == "*")
            {
#>for(var element in <#= name #>)
{
    tempList.AddRange(<#= name #>.ToUintList());
}
<#
            }
            else
            {
#>tempList.AddRange(<#= name #>.ToUintList());
<#
            }
        }
#>
ushort opCode = <#= opCode#>;
ushort wordCount = (ushort) (tempList.Count + 1);

uint combinedWord = SPIRVBuilderUtils.JoinOpCodeWordCount(opCode, wordCount);
_instructions.Add(combinedWord);
<#
        if (paramInfos.Count != 0)
        {
#>_instructions.AddRange(tempList);
<#
        }
#>
<#
        PopIndent();
#>
}

<#
    }
#>
using System;
using System.Collections.Generic;
using ILGPU.Backends.SPIRV.Types;

#nullable enable

namespace ILGPU.Backends.SPIRV {

<#
    PushIndent(standardIndent);
#>
/// <summary>
/// Defines utility methods to generate SPIRV operations
/// </summary>
[CLSCompliant(false)]
public class BinarySPIRVBuilder : ISPIRVBuilder
{

    private readonly List<uint> _instructions = new List<uint>();

    public byte[] ToByteArray() {
        uint[] uintArray = _instructions.ToArray();
        byte[] byteArray = new byte[uintArray.Length * 4];
        Buffer.BlockCopy(uintArray, 0, byteArray, 0, uintArray.Length * 4);
        return byteArray;
    }

    public void AddMetadata(
        uint magic,
        uint version,
        uint genMagic,
        uint bound,
        uint schema)
    {
        _instructions.Add(magic);
        _instructions.Add(version);
        _instructions.Add(genMagic);
        _instructions.Add(bound);
        _instructions.Add(schema);
    }

    public void Merge(ISPIRVBuilder other)
    {
        if(other == null)
            throw new ArgumentNullException(nameof(other));

        if(other is BinarySPIRVBuilder)
        {
            var otherBinary = (BinarySPIRVBuilder) other;
            _instructions.AddRange(otherBinary._instructions);
            return;
        }

        throw new InvalidCodeGenerationException(
            "Attempted to merge string representation builder with binary builder"
        );
    }

<#
    PushIndent(standardIndent);
    foreach (var instruction in grammar.Instructions.Instructions)
    {
        var paramInfos = GenerateParamInfos(instruction);
        CreateHeader(instruction.OpName, paramInfos);
        CreateBody(instruction.OpCode, paramInfos);
    }
    PopIndent();
#>
}
<#
    PopIndent();
#>
}
#nullable restore
